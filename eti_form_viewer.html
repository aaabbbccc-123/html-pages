<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>ETI Form Viewer</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <style>
      body {
        font-family: Arial, sans-serif;
        margin: 0;
        padding: 0;
        background: #f7f7f7;
      }
      #root {
        margin: 40px auto;
        max-width: 1440px;
        background: #fff;
        border-radius: 8px;
        box-shadow: 0 2px 8px rgba(0,0,0,0.08);
        padding: 32px;
      }
      textarea {
        width: 100%;
        min-height: 80px;
        font-size: 16px;
        padding: 8px;
        margin-bottom: 24px;
        border-radius: 4px;
        border: 1px solid #ccc;
        resize: vertical;
        box-sizing: border-box;
      }
      .surveyjs-container {
        margin-top: 40px;
        padding: 24px;
        background: #f1f8e9;
        border-radius: 6px;
        min-height: 200px;
        border: 1px solid #c5e1a5;
      }
    </style>
  </head>
  <body>
    <div id="root"></div>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script crossorigin src="https://unpkg.com/d3-dsv@3/dist/d3-dsv.min.js"></script>
    <script crossorigin src="https://unpkg.com/survey-react@1.9.124/survey.react.min.js"></script>
    <link rel="stylesheet" href="https://unpkg.com/survey-react@1.9.124/survey.min.css">
    <script type="text/javascript">
      const { useState } = React;
      function extractNone(choices, surveyType) {
        let showNoneItem = false;
        let processedChoices = [...choices];
        
        if (surveyType === 'checkbox' && Array.isArray(choices)) {
          const noneIdx = choices.findIndex(
            c => typeof c === 'string' && c.trim().toLowerCase() === 'none of the above'
          );
          if (noneIdx !== -1) {
            showNoneItem = true;
            processedChoices.splice(noneIdx, 1);
          }
        }
        return { showNoneItem, choices: processedChoices };
      }
      
      // Extract "Other" - matches backend extractOther logic
      function extractOther(choices, surveyType) {
        let showOtherItem = false;
        let processedChoices = [...choices];
        
        if ((surveyType === 'radiogroup' || surveyType === 'checkbox') && Array.isArray(choices)) {
          const otherIdx = choices.findIndex(
            c => typeof c === 'string' && c.trim().toLowerCase() === 'other'
          );
          if (otherIdx !== -1) {
            showOtherItem = true;
            processedChoices.splice(otherIdx, 1);
          }
        }
        return { showOtherItem, choices: processedChoices };
      }
      
      // Map ETI question type to SurveyJS type - matches backend mapToSurveyJSQuestionType
      function mapToSurveyJSQuestionType(etiType) {
        const typeMap = {
          'text': 'comment',
          'optional_text': 'comment',
          'radio': 'radiogroup',
          'checkbox': 'checkbox',
          'attachment': 'file'
        };
        return typeMap[etiType] || 'comment';
      }



      function parseTSV(tsvText, sectionDesc) {
        if (!tsvText || !tsvText.trim()) return null;
        
        const rows = d3.tsvParseRows(tsvText.trim());
        if (rows.length === 0) return null;

        // Column indices (fixed order)
        const typeIdx = 0;
        const sectionIdx = 1;
        const questionIdx = 2;
        const optionsIdx = 3;
        const filterIdx = 4;

        // Group questions by section - matches backend logic
        const grouped = {};
        
        for (const row of rows) {
          const section = row[sectionIdx] || 'General';
          
          if (!grouped[section]) {
            grouped[section] = [];
          }
          
          // Parse question data
          const questionType = (row[typeIdx] || '').trim().toLowerCase();
          const question = row[questionIdx] || '';
          let options = [];
          let filter = null;
          
          // Parse options for radio/checkbox
          if ((questionType === 'radio' || questionType === 'checkbox') && row[optionsIdx]) {
            try {
              options = JSON.parse(row[optionsIdx]);
            } catch (e) {
              console.warn('Failed to parse options:', row[optionsIdx], e);
              options = [];
            }
          }
          
          // Parse filter
          if (row[filterIdx]) {
            try {
              filter = JSON.parse(row[filterIdx]);
            } catch (e) {
              console.warn('Failed to parse filter:', row[filterIdx], e);
              filter = null;
            }
          }
          
          grouped[section].push({
            question,
            questionType,
            options,
            filter
          });
        }

        // Build SurveyJS pages - MATCHES BACKEND EXACTLY
        const pages = Object.entries(grouped).map(([section, questions]) => {
          const elements = questions.map((q, i) => {
            const { question, questionType, options, filter } = q;
            
            // Map to SurveyJS type using helper
            const surveyType = mapToSurveyJSQuestionType(questionType);
            const localIdx = i + 1; // 1-based index within section
            const name = `${section}_q${localIdx}`; // MATCHES BACKEND FORMAT
            const title = question;
            
            let choices = Array.isArray(options) ? [...options] : [];
            let showOtherItem = false;
            let showNoneItem = false;
            
            // Extract Other and None - MATCHES BACKEND ORDER
            ({ choices, showOtherItem } = extractOther(choices, surveyType));
            ({ choices, showNoneItem } = extractNone(choices, surveyType));
            
            let visibleIf = undefined;
            
            // Build filter conditions - MATCHES BACKEND LOGIC
            if (filter && typeof filter === 'object') {
              const conds = [];
              
              for (const [dependsKey, expected] of Object.entries(filter)) {
                const questionNum = Number(dependsKey);
                
                if (!isNaN(questionNum) && questionNum >= 1 && questionNum <= questions.length) {
                  const ref = `{${section}_q${questionNum}}`;
                  const dependencyQuestion = questions[questionNum - 1];
                  const dependencyType = dependencyQuestion?.questionType;
                  const isCheckboxDependency = dependencyType === 'checkbox';
                  
                  // Build condition based on dependency type
                  const buildCondition = (value) =>
                    isCheckboxDependency 
                      ? `${ref} contains '${value}'` 
                      : `${ref} = '${value}'`;
                  
                  if (Array.isArray(expected)) {
                    const condition = expected.map(v => buildCondition(v)).join(' or ');
                    conds.push(condition);
                  } else {
                    conds.push(buildCondition(expected));
                  }
                }
              }
              
              if (conds.length) {
                visibleIf = conds.join(' and ');
              }
            }
            
            // Build element - MATCHES BACKEND
            const el = {
              type: surveyType,
              name,
              title,
            };
            
            if (choices.length) {
              el.choices = choices;
            }
            if (visibleIf) {
              el.visibleIf = visibleIf;
            }
            if (showOtherItem) {
              el.showOtherItem = true;
            }
            if (showNoneItem) {
              el.showNoneItem = true;
              el.noneText = 'None of the above';
            }
            if (questionType !== 'optional_text') {
              el.isRequired = true;
            }
            
            // Attachment/file configuration - MATCHES BACKEND
            if (questionType === 'attachment') {
              el.storeDataAsText = false;
              el.waitForUpload = true;
              el.maxSize = 10 * 1024 * 1024; // 10MB
              el.acceptedTypes = 'application/pdf, image/jpeg, image/png, image/jpg';
              el.allowMultiple = true;
              el.maxFilesCount = 3;
            }
            
            return el;
          });
          
          return {
            name: section,
            title: section,
            description: sectionDesc[section] || '',
            elements,
          };
        });
        
        // Return SurveyJS schema - MATCHES BACKEND
        return {
          showQuestionNumbers: 'on',
          showProgressBar: 'top',
          pages,
        };
      }

      function SurveyJSRender({ json }) {
        
        const surveyContainerRef = React.useRef(null);

        React.useEffect(() => {
          if (surveyContainerRef.current && json) {
            // Unmount any previous React component before rendering a new one
            ReactDOM.unmountComponentAtNode(surveyContainerRef.current);

            // Render SurveyJS React component
            Survey.cssType = "bootstrap";
            const survey = new Survey.Model(json);
            ReactDOM.render(
              React.createElement(Survey.Survey, { model: survey }),
              surveyContainerRef.current
            );
          }
        }, [json]);

        return React.createElement('div', { className: 'surveyjs-container' },
          React.createElement('div', { ref: surveyContainerRef })
        );
      }
      // Tab component for switching between tabs
      function Tabs({ tabs, activeTab, onTabChange }) {
        return React.createElement(
          'div',
          { className: 'tabs', style: { marginBottom: 16, display: 'flex', gap: 8 } },
          tabs.map((tab, idx) =>
            React.createElement(
              'button',
              {
                key: tab,
                onClick: () => onTabChange(idx),
                style: {
                  padding: '8px 16px',
                  border: '1px solid #ccc',
                  background: idx === activeTab ? '#e9ecef' : '#fff',
                  cursor: 'pointer',
                  borderBottom: idx === activeTab ? '2px solid #007bff' : '1px solid #ccc',
                  fontWeight: idx === activeTab ? 'bold' : 'normal'
                }
              },
              tab
            )
          )
        );
      }
    // Implement getSections: parses TSV input and returns array of unique section names
        function getSections(tsvText) {
            if (!tsvText || !tsvText.trim()) return [];
            
            // Use d3.tsvParseRows for robust parsing
            const rows = d3.tsvParseRows(tsvText.trim());
            if (rows.length === 0) return [];
            
            const sectionIdx = 1; // Section is 2nd column
            
            // Collect unique sections in order
            const seen = new Set();
            const sections = [];
            
            for (const row of rows) {
                const name = row[sectionIdx];
                if (!name || seen.has(name)) continue;
                seen.add(name);
                sections.push(name);
            }
            
            return sections;
        }
      // Table to display sections and their descriptions
      function SectionTable({ sections, sectionDesc, setSectionDesc }) {
        // sections: array of section name (string)
        // sectionDesc: { [sectionName]: description }
        // setSectionDesc: function to update sectionDesc

        // Handler for description change
        function handleDescChange(sectionName, value) {
          setSectionDesc({
            ...sectionDesc,
            [sectionName]: value
          });
        }

        return React.createElement(
          'table',
          { className: 'table table-bordered', style: { width: '100%', background: '#fff' } },
          React.createElement(
            'thead',
            null,
            React.createElement(
              'tr',
              null,
              React.createElement('th', null, 'Section'),
              React.createElement('th', null, 'Description')
            )
          ),
          React.createElement(
            'tbody',
            null,
            (sections && sections.length > 0
              ? sections
              : []
            ).map((section, idx) =>
              React.createElement(
                'tr',
                { key: section || idx },
                React.createElement('td', null, section),
                React.createElement('td', null,
                  React.createElement('input', {
                    type: 'text',
                    value: sectionDesc[section] !== undefined
                      ? sectionDesc[section]
                      : '',
                    onChange: e => handleDescChange(section, e.target.value),
                    style: { width: '100%' }
                  })
                )
              )
            )
          )
        );
      }

      function EtiFormViewer() {
        const [multilineInput, setMultilineInput] = useState('');
        const [activeTab, setActiveTab] = useState(0);
        const [sectionDesc, setSectionDesc] = useState({});
        return React.createElement('div', null,
          React.createElement('h1', null, 'ETI Form Viewer'),
          React.createElement('div', { style: { marginBottom: 32 } },
            React.createElement(Tabs, {
              tabs: ['Questions', 'Sections'],
              activeTab,
              onTabChange: (tab) => setActiveTab(tab)
            }),
            activeTab === 0 && React.createElement('div', { style: { marginTop: 16 } },
              React.createElement('label', null,
                React.createElement('strong', {style: { display: 'block', marginBottom: 10}}, 'Multiline Input:'),
                React.createElement('textarea', {
                  value: multilineInput,
                  onChange: e => setMultilineInput(e.target.value),
                  placeholder: 'Enter your text here...'
                })
              )
            ),
            activeTab === 1 && React.createElement('div', { style: { marginTop: 16 } },
              React.createElement(SectionTable, { sections: (() => {
                try {
                  return multilineInput ? getSections(multilineInput) : null;
                } catch (e) {
                  return null;
                }
              })(),
              sectionDesc,
              setSectionDesc
            })
            ),
            React.createElement(SurveyJSRender, {
              json: (() => {
                try {
                  return multilineInput ? parseTSV(multilineInput, sectionDesc) : null;
                } catch (e) {
                  console.error('Error parsing TSV:', e);
                  return null;
                }
              })()
            })
          ),
        );
      }

      const root = ReactDOM.createRoot(document.getElementById('root'));
      root.render(React.createElement(EtiFormViewer));
    </script>
  </body>
</html>
